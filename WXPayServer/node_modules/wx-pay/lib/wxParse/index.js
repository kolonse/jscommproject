/**
 * Created by kolonse on 2017/4/10.
 */
var crypto = require("crypto");
var xml2js = require('xml2js');
var WXSig = require("../wxSig");

function WXParse(opt) {
    this.opt = opt || {};
    this.builder = new xml2js.Builder();
    this.opt.parseFlag = opt.parseFlag || parseFlag;
    this.wxSig = WXSig(opt);
}

WXParse.prototype.toWXPayXml = function(jsondata, secret) {
    var sig = this.wxSig.GenSig(jsondata, secret);
    jsondata.sign = sig;
    var xml = {
        xml: jsondata
    };
    return this.builder.buildObject(xml);
};

WXParse.prototype.MiddleWare = function() {
    var self = this;
    return function(req, res, next) {
        res.wxpayxml = function(jsondata, secret) {
            var xml = self.toWXPayXml(jsondata, secret);
            res.write(xml);
            res.end();
        };
        var func = bodyparser(self.opt);
        func(req, res, next, function() {
            var parseString = xml2js.parseString;
            parseString(req.body, function(err, result) {
                if (err) {
                    next(error(411, err.message));
                    return;
                }
                if (req.method.toUpperCase() === "GET") {
                    req.query = result;
                } else {
                    req.body = result;
                }

                next();
            });
        });
    };
};

module.exports = function(opt) {
    return new WXParse(opt);
};


var http = require('http');
var regexp = /^(text\/xml|application\/([\w!#\$%&\*`\-\.\^~]+\+)?xml)$/i;
var util = require('util');

function parseFlag(req) {
    return regexp.test(mime(req));
}

function bodyparser(options) {
    var flag = options.parseFlag || parseFlag;
    /**
     * Provide connect/express-style middleware
     *
     * @param {IncomingMessage} req
     * @param {ServerResponse} res
     * @param {Function} next
     * @return {*}
     */


    function bodyreceive(req, res, next, cb) {
        var data = '';
        /**
         * @param {Error} err
         * @param {Object} xml
         */
        if (req._body) {
            return next();
        }

        req.body = req.body || {};

        if (!hasBody(req) || !flag(req)) {
            return next();
        }

        req._body = true;

        // explicitly cast incoming to string
        req.setEncoding('utf-8');
        req.on('data', function(chunk) {
            data += chunk;
        });

        req.on('end', function() {
            // invalid xml, length required
            if (data.trim().length === 0) {
                return next(error(411));
            }
            req.body = data;
            cb();
        });
    }

    return bodyreceive;
}

/**
 * Test whether request has body
 *
 * @see connect.utils
 * @param {IncomingMessage} req
 * @return boolean
 */

function hasBody(req) {
    var encoding = 'transfer-encoding' in req.headers;
    var length = 'content-length' in req.headers && req.headers['content-length'] !== '0';
    return encoding || length;
}

/**
 * Get request mime-type without character encoding
 *
 * @see connect.utils
 * @param {IncomingMessage} req
 * @return string
 */

function mime(req) {
    var str = req.headers['content-type'] || '';
    return str.split(';')[0];
}

/**
 * Factory for new Error with statuscode
 *
 * @see connect.utils
 * @param {number} code
 * @param {*} msg
 * @return {Error}
 */

function error(code, msg) {
    var err = new Error(msg || http.STATUS_CODES[code]);
    err.status = code;
    return err;
}